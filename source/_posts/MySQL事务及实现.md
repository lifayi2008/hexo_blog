---
title: Mysql事务及实现
date: 2016-08-15 18:07:59
tags: MySQL
categories: 数据库
---
MySQL默认事务隔离级别是可重复读（Repeatable read），可以使用如下命令来查看：  
    
    show variables like 'tx_isolation'
<!-- more -->
可以使用如下方式指定全局或者单个会话的事务隔离级：  

    在my.cnf的[mysqld]配置块中指定：
    transaction-isolation = {READ-UNCOMMITTED | READ-COMMITTED | REPEATABLE-READ | SERIALIZABLE}
    
    在会话中使用如下语句进行设置：
    SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE}     //这里的名字中没有连字符
    
    使用如下语句查询全局和会话事务隔离级：
    SELECT @@global.tx_isolation;
    SELECT @@session.tx_isolation;
    SELECT @@tx_isolation;
    

#### 基本概念

**`事务`** ： 事务是一组原子性的SQL操作，这些语句被当作一个单元执行；如果事务中的所有语句都执行成功则事务执行成功，操作生效，否则事务执行失败，任何之前进行的操作应该进行回滚。事务的四个原则：
    
*   原子性：事务中的所有操作都是一个不可分割的单元，要么全部执行，要么都不执行
*   一致性：事务操作让数据库从一种一致性的状态变为另一种一致性的状态
*   隔离性：事务内部的操作对其他事务是不可见的
*   永久性：事务在未提交之前时可以进行回滚的，事务一旦提交则数据库的状态即被改变

**`读锁`** ： 也叫共享锁、S锁，若一个事务对数据对象加上S锁，则这个事务可以读这个数据对象但不能修改，其他事务只能再对这个数据对象加S锁，而不能加X锁，直到事务释放这个读锁。这保证了其他事务也可以读被加读锁的数据，但不能做任何修改

**`写锁`** ： 又称排他锁、X锁。若一个事务对一个数据对象加上写锁，则这个事务可以读也可以修改这个数据对象，其他事务不能再对这个数据对象加任何锁，直到释放数据对象上的锁

**`表级锁`** ： 即对整个数据表加锁，在MySQL中是由DBMS来实现，因此所有的数据库引擎都支持

**`行级锁`** ： 即对数据表中的某一行加锁，由数据库引擎来实现，Innodb支持这种锁；这种锁并发性能比较好，但同时也更消耗系统资源

**`MVCC`** ： 多版本并发控制（MVCC,Multiversion Currency Control）。一般情况下，事务性储存引擎不是只使用表锁，行加锁的处理数据，而是结合了MVCC机制，以处理更多的并发问题。Mvcc处理高并发能力最强，但系统开销最大（较表锁、行级锁）

#### 数据库并发操作时可能出现的问题

**`更新丢失(Lost Update)`** ： 如果两个事务同时对同一行数据进行操作，则可能两个事务都更新失败

**`脏读(Dirty Reads)`** ： 一个事务的更新操作还未提交，另外一个事务进行读取操作；如果第一个事务进行了回滚操作，则第二个事务读取到了中间数据（脏数据）

**`不可重复读(Non-repeatable Reads)`** ： 在一个事务中两次读取同一行数据，读取到的结果却不一样；这是因为有可能第一个事务再第一次读取这行数据后，另外一个事务对这行数据进行了更新

**`幻读(Phantom Reads)`** ： 第一个事务已经读取/更新过的行中被另外一个事务插入了一行数据

#### MySQL实现的隔离级

**`未提交读取(Read Uncommitted)`** ： 不允许更新丢失而允许另外三种情况；一个事务在对一行数据进行更新时对此行加共享锁，所以另外一个事务不能更新此行，但是可以读取此行，所以这种情况下就可能出现脏读；一个事务对一行数据进行读取时，不加锁，所以会有不可重复读的问题

**`提交读取(Read committed)`** ： 不允许更新丢失和脏读取，允许不可重复读和幻读；一个事务在对一行数据进行更新时会对此行加排它锁，直到事务提交时才释放，所以这种隔离级别不会出现脏读(读取到未提及的数据)；一个事务在对一行数据进行读取时加共享锁，读取完立刻释放，在这个事务中并不能保证读过的数据不被另外一个事务的更新操作修改，所以会出现不可重复读的问题

**`可重复读(Repeatable Reads)`** ： 不允许更新丢失、脏读取和不可重复读，但有可能会有幻读问题；一个事务在对一行数据进行更新时会对此行加排它锁，直到事务提交时才释放；一个事务在对一行数据进行读取时对此行加共享锁，直到事务提交时才释放，不可重复读的问题也被解决；但是不管在更新还是读取时都不能阻止另外一个事务插入一行数据，所以会出现幻读；但是后面就会看到MySQL通过MVCC(多版本并发控制)解决了幻读问题

**`序列化(Serializable)`** ： 上述四种问题都不会出现；事务开始前对整个表加锁，这种隔离级当然也失去了并发性

#### Innodb实现MVCC原理

InnoDB引擎在保存一行数据时另外记录两个字段值：创建版本号和删除版本号；并且在每一个事物开始时被赋予一个递增的事务号，然后根据操作类型来将事务号和两个版本号进行对比，或者使用事务号来更新两个版本号；详细操作如下：

**`SELECT`** ： 在查询时只返回同时符合如下条件的数据行 1.行的创建版本号小于或者等于当前事务号 2.行的删除版本号未定义或者大于当前事务号；只有创建版本号小于当前事务号的行才可能是当前事务开始之前存在的数据；另外如果行删除版本号存在并且小于当前事务号，则说明一个先开始的或者当前事务已经删除了这行数据，所以不应该被当前事务查询到

**`INSERT`** ： 使用当前事务号作为新插入的数据行的创建版本号，删除版本号为空

**`DELETE`** ： 使用当前事务号作为本行数据的删除版本号

**`UPDATE`** ： 复制本行作为一行新的数据，更新新行内容；使用当前事务号作为新行的创建版本号，删除版本号为空；使用当前事务号作为旧行的删除版本号；这样后面的事务可以看到新行的数据，而前面的事务（事务号在旧行创建版本号之后）仍可以看到旧的行内容

>上面的分析存在一个问题：如果直接拿当前事务号来进行对比的话，之前所有未提交事务的操作就会被当前事务看到，这是不应该出现的；所以在对比时应该排除掉当前未提交事务号